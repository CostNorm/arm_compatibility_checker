Perfect—I'll begin gathering AWS-official data and resources on the benefits and challenges of migrating EC2 workloads from x86 to Graviton (ARM), focusing on the last 24 months and using the `us-east-1` region for cost comparisons. I'll also compile benchmark data, pricing tables, customer case studies, and highlight any tools or services AWS offers to support such migrations. I’ll notify you as soon as the research is ready for your review.

# Migrating AWS EC2 Workloads from x86 to AWS Graviton (Arm)

Migrating Amazon EC2 workloads from traditional x86 processors (Intel/AMD) to AWS Graviton (Arm-based) instances can unlock significant benefits in cost, performance, and sustainability. This document covers three phases of the migration journey:

- **Phase 1:** The benefits of AWS Graviton and key AWS messaging (price-performance gains, performance improvements, cost savings, and energy efficiency), including real-world case studies.
- **Phase 2:** Common migration challenges and best practices (software compatibility, multi-architecture containers, CI/CD adjustments, code changes, and AWS tools to assist in the transition).
- **Phase 3:** A cost and performance comparison of equivalent x86 and Graviton instance types (t3 vs t4g, m5/m6i vs m6g/m7g, c5/c6i vs c6g/c7g, r5/r6i vs r6g/r7g), including on-demand pricing in us-east-1, instance specs, and price-performance benchmarks.

The goal is to provide a technical overview with evidence-backed insights to support a migration plan or value proposition for moving to AWS Graviton.

## Phase 1: AWS Graviton Benefits and Messaging

### Price-Performance Advantages of Graviton Instances

AWS Graviton processors (currently Graviton2 and Graviton3 generations) are designed to deliver superior price-performance for a wide range of workloads. AWS frequently cites **“up to 40% better price-performance”** for Graviton2-based instances compared to their x86 equivalents ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=AWS%20Graviton%20processors%20are%20custom,a%20wide%20variety%20of%20workloads)) ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=Migrating%20your%20Amazon%20Elastic%20Kubernetes,adaption%20to%20your%20operational%20requirements)). This means that for the same level of performance, Graviton instances can cost substantially less. For example:

- **General Purpose (M series):** Amazon EC2 M6g (Graviton2) instances deliver _up to 40% better price-performance_ over Intel-based M5 instances ([It is out: The CloudPanel for AWS Graviton](https://www.cloudpanel.io/blog/cloudpanel-for-aws-graviton/#:~:text=AWS%20announced%20that%20its%20M6g,than%20its%20own%20M5%20instances)). In internal tests, an Arm-based M6g provided **30% higher application performance and 20% lower cost** versus an M5 (together yielding ~40% price-perf gain) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=This%20big%20data%20heavy%20workload,benefits%20compared%20to%20M5%20instances)).
- **Burstable (T series):** T4g instances (Graviton2) offer _up to 40% better price-performance_ than T3 (x86) for burstable workloads ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=Best%20price%20performance%20for%20burstable,general%20purpose%20workloads)). They also exhibit 40% higher peak CPU performance than T3, allowing more headroom during bursts ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=With%20T4g%20instances%2C%20customers%20can,to%20T4g%20instances%20more%20effectively)).
- **Compute Optimized (C series):** C6g instances (Graviton2) similarly provide _up to 40% better price-performance_ compared to C5 (x86) instances ([Amazon EC2 R6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/r6g/#:~:text=Amazon%20EC2%20R6g%20Instances%20,price%20performance%20over%20R5%20instances)), making them cost-effective for CPU-intensive tasks.
- **Memory Optimized (R series):** R6g instances (Graviton2) are advertised with _up to 40% better price-performance_ than R5 (x86) instances ([r6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/r6g.xlarge#:~:text=Comparison%20instances,2016%20per%20hour)), a significant savings for memory-heavy workloads.

Graviton3, the latest generation, further improves performance. Graviton3-based instances (e.g., C7g, M7g, R7g) offer roughly **25% higher compute performance** than Graviton2-based instances ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=AWS%20announces%20the%20general%20availability,the%20%2066%20AWS%20Nitro)) ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=High%20performance%20for%20general%20purpose,workloads%20in%20Amazon%20EC2)). They also double certain capabilities: _up to 2× higher floating-point and cryptographic performance, and up to 3× better machine learning throughput_ compared to Graviton2 ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=AWS%20Graviton3%20processors%20are%20the,less%20energy%20for%20the%20same)) ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=AWS%20Graviton3%C2%A0is%20the%20latest%20generation,workloads%2C%20including%20support%20for%20bfloat16)). These improvements mean that workloads can run faster on the new M7g/C7g/R7g instances, potentially reducing the number of servers needed or improving user experience. For example, Amazon’s internal tests showed C7g (Graviton3) delivered **25% better performance than C6g (Graviton2)** on a broad set of applications ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=The%20latest%20generation%20compute%20optimized,inference%2C%20and%20ad%20serving)). In customer trials, Twitter saw up to **80% better performance** moving from C6g to C7g for some services, with tail latencies reduced by 35% ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=tested%20their%20workloads%20on%20Graviton3,for%20their%20telemetry%20ingestion%20workload)) (highlighting Graviton3’s gains, even over an already-optimized Arm generation).

Importantly, AWS emphasizes that these gains come with **no premium in instance pricing** – in fact, Graviton instances are priced lower on a per-hour basis than comparable x86 instances. We will see specific pricing in Phase 3, but as an illustration, an M6g.xlarge costs about 20% less per hour than an M5.xlarge in the same region, yet can often handle the same or greater load ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,for%20the%20underprivileged%20segments%20of)). This direct cost savings, combined with performance boosts, results in significantly better value. AWS sums it up: _“Amazon EC2 instances powered by AWS Graviton processors provide up to 40% better price-performance over comparable x86-based instances for a wide variety of workloads.”_ ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=AWS%20Graviton%20processors%20are%20custom,a%20wide%20variety%20of%20workloads))

### Energy Efficiency and Sustainability

Beyond raw performance and cost, AWS Graviton offers **improved energy efficiency**, aligning with sustainability goals. AWS reports that Graviton3-based instances use _up to 60% less energy for the same performance_ compared to traditional x86 instances ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=processors.%20Graviton3,They%20offer)) ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=Graviton3,metal%20sizes)). This is a huge efficiency gain – in practice, it means lower power and cooling requirements for the equivalent compute work. For cloud users, this manifests as both lower cost (since AWS can pass on efficiency gains) and the ability to reduce the carbon footprint of workloads by nearly half or more. AWS has explicitly framed Graviton as a way to _decarbonize compute_ in the data center, given its performance-per-watt advantages.

For example, an AWS Containers blog notes that migrating to Graviton can yield **up to 60% energy reduction** while still achieving up to 40% better price-performance ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=Migrating%20your%20Amazon%20Elastic%20Kubernetes,adaption%20to%20your%20operational%20requirements)). These efficiency gains are due to Graviton’s modern 64-bit Arm core design and the absence of legacy overhead – essentially doing more work per unit of power. Organizations with green objectives or those monitoring cloud energy consumption can leverage Graviton instances to make significant strides; AWS even highlights this as helping customers meet sustainability targets ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=More%20and%20more%20businesses%20are,to%20read%20the%20full%20quote)). In summary, Graviton processors deliver more performance per watt, translating to _both_ cost savings and environmental benefits.

### Workload Performance and Customer Case Studies

Many organizations have validated AWS’s claims by migrating real production workloads to Graviton and reporting **improved performance and lower costs**. A few notable examples from AWS case studies and testimonials:

- **Ascend Money (Fintech):** Migrated big data analytics workloads (Amazon EMR and OpenSearch) from M5 (x86) to M6g (Graviton2) in under one week. They observed _“40% better price-performance, including 20% lower cost per instance, without any major code changes.”_ ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,for%20the%20underprivileged%20segments%20of)) This immediate savings allowed them to reinvest funds into further innovation. The migration process was seamless, indicating good compatibility for their Java and data processing tools.
- **Ably (Realtime Messaging Service):** Ported the majority of their Java, Ruby, and Go services to Graviton with minimal effort. Results included _“up to 40% better price-performance over comparable x86 instances”_, achieved by a single engineer updating their CI/CD for multi-architecture builds and ensuring all dependencies had Arm64 support ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D)). Importantly, they met all their real-time latency benchmarks on Graviton, proving no degradation in quality of service ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D)).
- **Aerospike (Database Vendor):** In testing CPU-bound database workloads, **1.6× price-performance improvement** was seen with Graviton2 vs. x86 – effectively a 60% boost in cost efficiency ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D)). Aerospike’s CTO noted this substantial gain and was excited for customers to reap the savings on the new I4g (Graviton2) storage-optimized instances.
- **Beamr (Media Optimization):** This company rebuilt a C/C++ image processing application to run on C7g (Graviton3) instances. The porting took only one day, and they saw a **30% performance increase** compared to the x86 version ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=performance%20on%20AWS%20Graviton3,on%20Graviton%20instances%20as%20well)). Such a quick win (with virtually no cost other than the rebuild) demonstrates how certain workloads can run faster on Graviton due to its CPU architecture advantages for specific algorithms.
- **Honeycomb.io (Telemetry SaaS):** An early adopter of Graviton2, saw **35% higher performance and 30% lower latency** on their ingestion workload after moving to C6g, relative to previous x86 instances ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=reported%20a%20reduction%20in%20tail,for%20their%20telemetry%20ingestion%20workload)). This improved both their throughput and responsiveness.
- **Fluid Attacks (Cybersecurity):** Combined AWS Graviton instances with EC2 Spot to achieve **70% cost savings** overall for their compute platform ([70% Cost Savings Using AWS Graviton with Fluid Attacks | Case Study | AWS](https://aws.amazon.com/solutions/case-studies/fluid-attacks-case-study/#:~:text=Fluid%20Attacks%20Fuels%2070,Savings%20with%20AWS%20Graviton)). While a portion of this is due to using spare capacity (Spot), Graviton’s lower baseline cost enabled a much higher total savings, freeing budget for the company to reinvest in R&D ([70% Cost Savings Using AWS Graviton with Fluid Attacks | Case Study | AWS](https://aws.amazon.com/solutions/case-studies/fluid-attacks-case-study/#:~:text=Cybersecurity%20provider%20Fluid%20Attacks%20is,lab%2C%20team%2C%20and%20innovative%20solutions)).

These cases underline a common theme: **substantial cost savings (often 20–30% or more) and performance gains** after migrating to Graviton, often with minimal code changes. In many instances, organizations either maintained the same performance at a much lower cost or improved performance at the same cost – both of which improve price/performance. It’s also notable that major AWS customers (Epic Games, Formula 1, Snap, Twitter, etc.) have tested Graviton extensively ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=the%20Amazon%20Elastic%20Block%20Store,Amazon%20EBS)). Twitter, for example, found that by moving workloads to C7g they could improve performance by 80% vs. C6g ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=tested%20their%20workloads%20on%20Graviton3,latency%20compared%20with%20C6g%20for)) – indicating an even larger leap if compared to older x86 infrastructure. Such endorsements from high-scale users suggest that Graviton is production-ready and excelled even in demanding environments.

In summary, AWS Graviton’s value proposition as communicated by AWS and evidenced by customers is: **significantly better price-performance (around 40% in many cases), strong absolute performance for real workloads, direct cost savings on EC2 bills, and improved energy efficiency**. These advantages make a compelling case for migrating workloads to Arm-based instances, as long as the workloads are compatible. The next phase discusses what it takes to make that migration – i.e., the challenges and best practices when porting software from x86 to Arm.

## Phase 2: Migration Challenges and Best Practices (x86 to Graviton)

Moving an application from x86 to AWS Graviton requires some preparation, but AWS and the community have developed guidelines and tools to simplify the process. In many cases, the transition is straightforward (**“many customers adopt Graviton with minimal effort”** ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=x86,variety%20of%20workloads))), especially for applications written in high-level languages or using common runtimes. That said, engineers should be aware of key challenges in these areas:

- **Software and OS Compatibility** – Ensuring the operating system, libraries, and packages support 64-bit Arm (Arm64/AArch64).
- **Container and Build Process** – Handling multi-architecture container images or binaries (building for Arm64 in addition to x86).
- **CI/CD Pipeline Adjustments** – Updating build/test/deploy pipelines to incorporate Arm instances or cross-compilation.
- **Performance Tuning and Testing** – Verifying that the application behaves correctly and optimally on Graviton, and making any optimizations (e.g. for CPU core differences).
- **AWS Migration Tools and Programs** – Leveraging AWS initiatives like the Graviton Ready program, Porting Advisor, and others that help in the migration journey.

Each of these is discussed below, along with best practices:

### Software Compatibility and Architecture Support

**Operating Systems:** The first requirement is running an OS that supports Arm64 on EC2. All major modern Linux distributions do (Amazon Linux 2, Ubuntu, Red Hat, SUSE, Debian, etc., have Arm64 builds) ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=AWS%20Graviton2,ECS%2C%20Amazon%20EKS%2C%20Amazon%20ECR)). If you are using Amazon Linux or another supported distro on x86, you can usually find an equivalent AMI/OS release for Arm without much trouble. Note that **Windows is _not_ supported on Graviton** (there are no Windows Arm instances on EC2 as of now), so Windows-based workloads need to be migrated to Linux to use Graviton. This often involves porting Windows applications or frameworks (for example, .NET Framework apps) to Linux-compatible versions (more on this below).

**Libraries and Packages:** Inventory all software components in your stack and verify Arm64 availability ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=To%20start%20the%20move%2C%20the,monitoring%20or%20security%20agents)) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=For%20each%20component%20of%20your,and%20the%20more%20likely%20you%E2%80%99ll)). Common runtime environments like Java (OpenJDK), Node.js, Python, Go, Ruby, etc., have Arm64 versions available, so pure application code in these languages typically works out-of-the-box on Graviton. The challenges usually arise with **native dependencies** or third-party packages:

- If your application uses compiled native libraries (e.g., a Python C extension, a Ruby gem with native code, a machine learning library like TensorFlow, etc.), you need an Arm-compatible build of those libraries. Many popular libraries now provide pre-built Arm64 wheels/binaries due to growing Arm adoption. If not, you might need to compile them from source on an Arm system.
- **Outdated or niche software:** If any component is very old or obscure, it may not have Arm support. In such cases, you may need to find an alternative or update that component. AWS provides an open-source **Porting Advisor for Graviton** tool to help with this analysis: it scans your source code and dependency chain to highlight any unsupported libraries or architecture-specific code that would need changes ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,source%20code%20and%20library%20dependencies)). This can save time by pinpointing problematic areas (for example, code using x86 assembly or dependencies lacking Arm versions).
- **Container images:** If using Docker or containerized workloads, ensure that your container base images and any images you pull are multi-arch or have an Arm64 variant. Many official images (NGINX, Redis, Alpine, etc.) and AWS public images are multi-architecture, meaning the same image tag supports multiple architectures. Docker manifest lists allow pushing a single image name that contains both amd64 and arm64 versions. AWS ECR fully supports multi-architecture images and even provides a _pull-through cache_ for common public images to ease this process ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,g)). The key is to rebuild your application container for arm64 and publish it appropriately. In a mixed environment (during transition, you might be running some x86 and some Arm instances), using multi-arch manifests ensures the correct image is pulled for each architecture automatically.

**Build/Compile Considerations:** Applications written in C/C++ or other compiled languages will need to be recompiled for Arm64. Most modern build systems (gcc, clang, etc.) support cross-compiling to Arm, but it’s often easiest to do the build natively on an Arm EC2 instance (or in an Arm container). If your CI/CD runners are currently x86-only, you might introduce an AWS Graviton-based CI runner or use AWS CodeBuild with Arm environments to compile your code for Arm. In some cases, specifying `-march=armv8-a` or similar flags might be needed, but generally _little source code change is required_ unless you have low-level architecture-specific logic. For instance, one AWS user noted that migrating a C++ image processing algorithm to Arm was trivial – the code compiled and ran with no special modifications, immediately benefiting from the new architecture’s performance ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=performance%20on%20AWS%20Graviton3,on%20Graviton%20instances%20as%20well)).

**CPU Architecture Differences:** It’s worth noting a few architectural differences between AWS Graviton and typical Intel/AMD CPUs:

- Graviton cores do **not** support simultaneous multithreading (SMT/Hyper-Threading). Each vCPU _is_ a full physical core ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=One%20of%20the%20major%20differences,latencies%20or%20error%20rates%20occur)). This can actually simplify performance tuning: you don’t have the “two threads per core” behavior of an Intel hyper-threaded CPU. In practice, many workloads see better **scaling and consistency** on Graviton because of this – you get near-linear scaling with added vCPUs without contention on sibling threads ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=One%20of%20the%20major%20differences,significantly%20higher%20transaction%20rate%20before)). However, it also means if your x86 instance was counting on two threads per core, you should compare on a per-vCPU basis (AWS vCPUs are equal in count, but each Graviton vCPU is single-threaded vs. an Intel vCPU which is one hyperthread). For CPU-bound multi-threaded apps, Graviton often sustains higher throughput until hitting a cap, as noted in the AWS guide ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=%28SMT%29,latencies%20or%20error%20rates%20occur)).
- The instruction sets differ: Graviton supports Armv8 (including Neon for SIMD, SVE for some models, etc.) in place of x86 AVX/AVX2. Most high-level code won’t notice this. If you use **hand-optimized assembly or CPU intrinsics**, you may need an Arm equivalent. Many libraries abstract this or have both versions internally. This is one thing the Porting Advisor checks for in source code ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,source%20code%20and%20library%20dependencies)).
- Endianness is the same (little-endian), so data formats and networking don’t have surprises. One potential gotcha could be binary serialization that is architecture-specific (rare these days, but something to test).
- **Networking and I/O**: Graviton instances use the AWS Nitro system just like newer x86 instances, so performance for EBS, networking, etc., is similar. Some Graviton instance types even have _higher_ memory bandwidth (Graviton3 uses DDR5 memory – 50% higher memory bandwidth than DDR4 used in x86 instances ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=Amazon%20Elastic%20Compute%20Cloud%20,access%20to%20data%20in%20memory))) which benefits memory-intensive apps.

**Best Practice:** **Audit your software stack for Arm support early.** AWS suggests making an inventory of OS, libraries, frameworks, build tools, and agents you use ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=To%20start%20the%20move%2C%20the,monitoring%20or%20security%20agents)) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=for%20more%20details.%20,generates%20a%20report%20highlighting%20missing)). For each, find the Arm64-supported version (upgrading to the latest version of a library if needed, since newer versions are more likely to support Arm). In many cases, if you’re using standard Linux packages or containers, this step is simple (just use the Arm release). By doing this homework upfront, you can avoid roadblocks when you switch the underlying instance type.

### Building Multi-Architecture Containers and CI/CD Adjustments

If your deployment is containerized (e.g., on Amazon ECS or EKS), migrating to Graviton will involve producing a container image that can run on Arm. Docker and ECR have robust support for this:

- Use **Docker Buildx** to build multi-arch images. For example, you can build for both `linux/amd64` and `linux/arm64` platforms in one command and push a manifest so that `docker pull myapp:latest` will fetch the appropriate architecture for the host. This enables a _single image tag_ for both architectures ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=In%20this%20post%2C%20you%20get,level%20architecture)).
- In CI pipelines, you might add a build stage on an Arm node or use QEMU emulation for Arm in an x86 environment. Many CI systems (GitHub Actions, GitLab CI, Jenkins, etc.) support Arm runners now. If using AWS CodeBuild, you can select an Arm-based environment image to natively build your code on Graviton.
- **Kubernetes/EKS considerations:** During a transition, you may run a mixed cluster (x86 and Arm nodes). Tools like **Karpenter** or Cluster Autoscaler can be used to spin up Arm nodes gradually ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=preparation%20and%20adaption%20to%20your,operational%20requirements)). You’ll want to use Kubernetes node selectors or taints/tolerations to schedule workloads onto the right architecture. Alternatively, if using EKS managed node groups, create a separate node group for Arm instances and migrate services over by updating their node selectors or affinities.
- **Gradual rollout:** It’s a best practice to _canary_ or incrementally shift traffic to the new Graviton instances. Start by running a few instances in a test environment or a subset of your production (for stateless services, you can put some Arm instances behind the same load balancer as x86 ones and send a small percentage of traffic). Monitor performance and errors. AWS recommends a **blue/green or canary deployment** approach for migration ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=Task%208%3A%20Perform%20Canary%20or,Green%20deployment)), so you can easily rollback if something unexpected occurs.
- **Monitoring and dashboards:** During the migration, keep an eye on metrics like CPU utilization, latency, error rates, etc., on the Graviton instances vs the x86 ones. In many cases you’ll notice the Graviton instances handling more load per vCPU (due to the absence of hyper-threading and more efficient cores) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=One%20of%20the%20major%20differences,latencies%20or%20error%20rates%20occur)). You may be able to raise Auto Scaling thresholds because each instance can sustain more work before hitting bottlenecks ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=most%20cases,latencies%20or%20error%20rates%20occur)). AWS’s **Graviton Savings Dashboard** in the Cost Explorer can help visualize cost impacts and track usage of Graviton over time ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=the%20free%20tier%20FAQs%20page,for%20more%20details)).

([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/)) _Multi-architecture build and deploy pipeline for migrating to AWS Graviton._ In this example, container images are built for both x86_64 and arm64 and pushed to Amazon ECR. Kubernetes (Amazon EKS) can then schedule workloads onto either **x86 nodes or Graviton (Arm) nodes**, here facilitated by Karpenter for on-demand scaling. This approach enables a **gradual migration**: the same application can run on mixed architecture during the transition period, with no downtime ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=Migrating%20your%20Amazon%20Elastic%20Kubernetes,adaption%20to%20your%20operational%20requirements)) ([Migrating from x86 to AWS Graviton on Amazon EKS using Karpenter | Containers](https://aws.amazon.com/blogs/containers/migrating-from-x86-to-aws-graviton-on-amazon-eks-using-karpenter/#:~:text=In%20this%20post%2C%20you%20get,level%20architecture)).

### Code Refactoring and Performance Testing

**Application Code:** Most applications won’t require code changes to run on Graviton aside from the compatibility items already mentioned. However, once the app is running, it’s important to **test it thoroughly**:

- Run your full test suite on the Graviton-based instances. All unit, integration, and system tests should pass as they did on x86 ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=Task%205%3A%20Testing%20and%20optimizing,your%20workloads)). If any test fails, investigate if it’s an architecture-specific issue or an environmental difference. For example, a timing-sensitive test might need adjustment if performance is different. AWS notes that most issues at this stage are due to **missing dependencies or version differences** encountered earlier ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=Now%20that%20you%20have%20your,reach%20out%20to%20your%20AWS)). If you suspect an architecture-specific bug (perhaps a subtle concurrency issue that only appears on Arm), AWS’s Graviton Technical Guide and support channels can help troubleshoot ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=updated%20software%20versions%20you%20have,the%20AWS%20support%20for%20assistance)).
- After functional testing, conduct **performance benchmarking** on Graviton. Measure throughput, response times, CPU usage, memory usage, etc., under load. Compare these with baseline metrics from x86 instances. In many cases, you’ll find equal or better performance at lower cost. For example, if an M5.xlarge was 60% utilized for your workload, an M6g.xlarge might handle the same load at only 40% utilization (thanks to more efficient CPU use) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=This%20big%20data%20heavy%20workload,benefits%20compared%20to%20M5%20instances)). You might even test a size smaller – perhaps an M6g Large (2 vCPUs) could handle what an M5 Xlarge (4 vCPUs) did, due to better per-core performance and no hyperthreading contention.
- **Optimization:** If the performance on Graviton isn’t as expected, identify the bottlenecks. It could be a single-threaded part of the application now running on a slightly lower clock speed (Graviton cores often run at lower GHz but make up for it with more Instructions Per Cycle and more cores). It could also be something like using older crypto libraries – note Graviton3 has significantly faster crypto accelerators, but your app has to use them. Ensure you use up-to-date libraries that can leverage Arm features (e.g., use OpenSSL 1.1.1 or higher which can take advantage of Armv8 crypto extensions). The AWS Graviton Technical Guide provides language-specific tuning tips for maximum performance ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=resolving%20source%20code%20and%20library,dependencies)) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=Important%3A%20This%20repository%20has%20sections,to%20follow%20during%20this%20stage)).
- **Right-sizing:** With the performance data in hand, you might choose to resize instance types. Since Graviton instances are often more powerful per vCPU for certain workloads, you could potentially use a smaller instance size or fewer instances to handle the same traffic. AWS mentioned that after moving to Graviton, you may be able to increase CloudWatch alarm thresholds for Auto Scaling (because each instance handles more load), thereby **reducing the total number of instances needed** for a given workload ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=most%20cases,latencies%20or%20error%20rates%20occur)). This contributes further to cost savings.
- It’s also important to ensure that any **automation, infrastructure-as-code, or scaling policies** are updated for the new instance types. For example, update AWS CloudFormation/Terraform templates to reference the new instance family (and corresponding AMI). If you use EC2 Auto Scaling groups, you can use mixed instance policies or multiple launch templates to support both architectures during transition ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=Task%207%3A%20Update%20your%20infrastructure,as%20code)). Eventually, you’ll phase out the x86 launch template once fully migrated.

**Common Challenges Observed:** Some migration stories reveal minor refactoring that was needed:

- Updating numeric types or handling for different architecture bitness (though both x86_64 and arm64 are 64-bit, so this usually isn’t an issue like it was moving 32→64-bit).
- Removing any hardcoded assumptions about CPU architecture. E.g., one team mentioned an issue with how their application parsed `/proc/cpuinfo` or used an `uname` system call, expecting “x86_64” and failing if it got “aarch64”. Such checks should be made architecture-agnostic or extended to recognize Arm64.
- Ensuring build systems don’t pass architecture-specific flags by default. Sometimes build scripts had `-march=core2` or similar flags; changing or removing those allowed a clean Arm build.

Overall, the refactoring required is usually **minimal**. As AWS puts it, _“in most cases transitioning to AWS Graviton is as simple as updating your infrastructure-as-code to select the new instance type and associated OS, then testing your application”_ ([aws-graviton-getting-started/transition-guide.md at main - GitHub](https://github.com/aws/aws-graviton-getting-started/blob/main/transition-guide.md#:~:text=aws,and%20associated%20Operating%20System)). Many customers report they **did not need to change any application code** – they just had to use Arm-compatible libraries and then everything “just worked.” The key is comprehensive testing to gain confidence before and after the cut-over.

### AWS Tools and Programs to Assist Migration

AWS provides several resources to help make the migration smoother:

- **AWS Graviton Ready Program:** This is a partner program where many popular software products (operating systems, databases, monitoring tools, security software, etc.) are certified to run on Graviton. AWS has worked with ISVs to ensure their offerings support Arm. The program offers a catalog of Graviton-ready solutions, so if you use third-party software (like Datadog agent, Trend Micro security, etc.), you can check if they are “Graviton Ready”. This gives confidence that those vendors officially support running on Arm instances. _“The AWS Graviton Ready program offers certified solutions from partner software vendors that you can use on AWS Graviton-based instances.”_ ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=Extensive%20software%20support)). In practice, this means your tooling for logging, monitoring, CI/CD, etc., likely already works on Graviton or there’s a ready version available.
- **Graviton Technical Guide (GitHub):** AWS has published a technical guide on GitHub that provides a wealth of info – from how to optimize code in various languages for Graviton, to specifics on tuning the Linux kernel, JVM, etc., for Arm. It’s a living document that complements official docs, and it’s referenced in the Getting Started Guide ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=AWS%20Summit%20SF%202022%20,of%20silicon%20innovation%20at%20AWS)).
- **Porting Advisor for Graviton:** (Already discussed) a CLI tool that scans source code for non-compatible patterns ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,source%20code%20and%20library%20dependencies)). It’s especially useful for C/C++ or even Java code that might have some JNI native bits. Running this analysis early in the project can highlight issues when planning the effort.
- **Porting Assistant for .NET:** If you have **.NET Framework** applications (which run on Windows/x86), migrating to Graviton entails moving to **.NET Core/.NET 6+ on Linux**, since Graviton instances only run Linux. Porting Assistant for .NET is an AWS tool that scans your old .NET Framework code and identifies changes needed to make it run on .NET Core ([Porting Assistant for .NET - Amazon Web Services](https://aws.amazon.com/porting-assistant-dotnet/#:~:text=Porting%20Assistant%20for%20,generates%20a%20detailed%20compatibility%20assessment)). It will help you replace Windows-only APIs or obsolete libraries with cross-platform ones. This tool doesn’t directly “make it Arm-compatible” (because once you’re on .NET 6, it’s cross-platform by design), but it’s a crucial step for any Windows-based .NET apps that you want to host on Arm Linux. The value is that by modernizing to .NET on Linux, you _“take advantage of the performance [and] cost savings of Linux”_ and unlock the ability to run on Graviton ([Porting Assistant for .NET - Amazon Web Services](https://aws.amazon.com/porting-assistant-dotnet/#:~:text=Porting%20Assistant%20for%20,NET%20Core%20can%20be%20a)). Many users have used this to move legacy enterprise apps off Windows servers to Linux on Graviton, achieving huge cost reductions (no Windows licensing and cheaper instances).
- **AWS Graviton Fast Start Program:** AWS has (or had) programs to help customers trial Graviton – including free trials (T4g.small free for 750 hours per month, which has been extended through 2025 ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=Try%20Amazon%20EC2%20T4g%20Instances,Today))) and solution architects or support engineers to assist high-value migrations. The Fast Start program ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=To%20learn%20more%2C%20see%20Amazon,AWS)) and the **Graviton Challenge** (an educational initiative) are there to reduce risk for first-time adopters. Taking advantage of the T4g free trial is a good idea to do initial tests at no cost.
- **Compute Optimizer Recommendations:** AWS Compute Optimizer can now recommend instance type changes that include Graviton options. For example, if it sees an M5 instance underutilized, it might suggest switching to an M6g of smaller size to save money. These insights can identify where Graviton could yield savings without performance loss.
- **Migration Hub and Strategy Guides:** While AWS Migration Hub is primarily for tracking app migrations (e.g., from on-prem to cloud), it can be used to organize the transition of instances as well. Additionally, AWS Prescriptive Guidance has some docs on migrating workloads to Arm with step-by-step approaches and even specific strategies for certain types of applications ([Migrating .NET applications - AWS Prescriptive Guidance](https://docs.aws.amazon.com/prescriptive-guidance/latest/migration-microsoft-workloads-aws/migrating-net-workloads.html#:~:text=Migrating%20.NET%20applications%20,NET%20Refactoring)).

**In summary**, migrating to Graviton requires attention to compatibility and process, but AWS has smoothed the path considerably. The common pattern is: _update your infrastructure to launch Arm instances, ensure all software dependencies support Arm, build or deploy your app on the new instances, test thoroughly, then cut over gradually._ By leveraging multi-arch builds, tools like Porting Advisor, and taking advantage of AWS programs, even challenges like dealing with legacy .NET or obscure dependencies can be addressed. Many companies have completed the migration in days or weeks (as seen with Ascend Money’s one-week migration and Ably’s single-engineer effort over a couple of months with lots of services ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D)) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,for%20the%20underprivileged%20segments%20of))). Once the migration is done, the ongoing operational effort is no different than before – except now one can enjoy lower bills and better performance.

The final phase below will present concrete comparisons of instance specs and costs to quantify the benefits of choosing Graviton instances over x86 instances.

## Phase 3: Cost and Performance Comparison – x86 vs Graviton Instances

To make informed decisions, it’s useful to compare specific instance types between x86 and Graviton families. Below we present comparisons for several families in **us-east-1** region On-Demand pricing, including vCPU count, memory, and any noted performance claims from AWS. We also discuss how savings plans or reserved instances factor in.

**Key observation:** AWS prices Graviton-based instances lower than or equal to the x86 instances of similar size. Thus, any performance gain from Graviton translates to immediate price-performance win. Even in cases where Graviton is equal performance, the cost is lower, so you save money straight away.

Let’s look at four groups of equivalent instances:

### Burstable General Purpose: T3 vs T4g

These are burstable instances with baseline CPU and credit-based bursting – commonly used for low traffic web servers, dev/test, etc.

| Instance Type                     | vCPUs | Memory | On-Demand Cost (us-east-1)                                                                                                                          | Notes                                                                                                                                                                                                                                                          |
| --------------------------------- | ----- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **t3.large** (Intel Xeon Skylake) | 2     | 8 GiB  | $0.0832 per hour ([t4g.large instance pricing of AWS-EC2](https://www.instance-pricing.com/provider=aws-ec2/instance=t4g.large#:~:text=ap,Ohio%29)) | Baseline 20% CPU per vCPU, bursts with credits.                                                                                                                                                                                                                |
| **t4g.large** (Graviton2)         | 2     | 8 GiB  | $0.0672 per hour ([t4g.large instance pricing of AWS-EC2](https://www.instance-pricing.com/provider=aws-ec2/instance=t4g.large#:~:text=ap,Ohio%29)) | ~19% lower cost than t3.large. Best price-performance burstable instance ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=Best%20price%20performance%20for%20burstable,general%20purpose%20workloads)). |

**Price-Performance:** AWS claims T4g offers _up to 40% better price-performance over T3_ ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=Best%20price%20performance%20for%20burstable,general%20purpose%20workloads)). The pricing above shows the raw cost is ~19% less. T4g also has 20% higher CPU credits generation and higher all-core turbo frequencies, which contribute to the performance side of the equation ([Amazon EC2 T4g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/t4/#:~:text=With%20T4g%20instances%2C%20customers%20can,to%20T4g%20instances%20more%20effectively)). Many workloads on T4g.small (as part of AWS’s trial) have demonstrated significantly lower cost for the same throughput versus T3.

**Migrating Considerations:** T3 and T4g both use the Nitro Hypervisor and support the same features. If you’re running a burstable workload, moving from t3 to t4g requires no application changes – just launch the T4g instance and ensure the AMI is Arm-compatible (Amazon Linux 2, Ubuntu, etc., all have Arm images). CPU credits work the same way on both. In Unlimited mode, the overage cost per vCPU-hour is also identical across T3 and T4g ([EC2 On-Demand Instance Pricing – Amazon Web Services](https://aws.amazon.com/ec2/pricing/on-demand/#:~:text=T2%2FT3%2FT4g%20Unlimited%20Mode%20Pricing,For%20T2)) (currently $0.04 per vCPU-hour for Linux). So there’s no hidden cost – you simply save roughly 20% per hour and get more peak performance.

### General Purpose: M5 / M6i vs M6g / M7g

General purpose instances are used for balanced CPU/memory usage (ratio ~4 GiB memory per vCPU). Here we compare two generations of x86 (M5 and M6i) with Graviton2 (M6g) and Graviton3 (M7g).

| Instance Type                            | vCPUs | Memory | On-Demand Cost (us-east-1)                                                                                                                                                                        | Notes                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ---------------------------------------- | ----- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **m5.xlarge** (Intel Xeon, 5th Gen)      | 4     | 16 GiB | $0.192 per hour ([m5.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/m5.xlarge#:~:text=Comparison%20instances,192%20per%20hour))                  | Baseline x86 general purpose (2017 era CPU).                                                                                                                                                                                                                                                                                                                                                                                   |
| **m6i.xlarge** (Intel Ice Lake, 6th Gen) | 4     | 16 GiB | $0.192 per hour ([m6i.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/m6i.xlarge#:~:text=Comparison%20instances,192%20per%20hour))                | Latest Intel gen; similar price to M5. ~15% better perf than M5 ([Amazon EC2 C6i Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6i/#:~:text=Amazon%20EC2%20C6i%20Instances%20,C5%20instances%20for%20a)).                                                                                                                                                                                         |
| **m6g.xlarge** (Graviton2)               | 4     | 16 GiB | $0.154 per hour ([m6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/m6g.xlarge#:~:text=m6g.xlarge%20pricing%20and%20specs%20,154%20per%20hour)) | ~20% lower cost than M5/M6i. Up to 40% better price-perf vs M5 ([It is out: The CloudPanel for AWS Graviton](https://www.cloudpanel.io/blog/cloudpanel-for-aws-graviton/#:~:text=AWS%20announced%20that%20its%20M6g,than%20its%20own%20M5%20instances)).                                                                                                                                                                       |
| **m7g.xlarge** (Graviton3)               | 4     | 16 GiB | $0.1632 per hour ([m7g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/m7g.xlarge#:~:text=Comparison%20instances,1632%20per%20hour))              | ~15% lower cost than M6i. ~25% better perf than M6g ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=High%20performance%20for%20general%20purpose,workloads%20in%20Amazon%20EC2)). DDR5 memory (50% more bandwidth) ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=Amazon%20Elastic%20Compute%20Cloud%20,access%20to%20data%20in%20memory)). |

**Analysis:** For a 4 vCPU, 16 GiB instance:

- M5 and M6i are priced the same at $0.192. AWS often kept pricing constant across generations and delivered performance improvements instead (indeed M6i has newer CPUs that AWS said give _~15% better price-performance than M5_ ([Amazon EC2 C6i Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6i/#:~:text=Amazon%20EC2%20C6i%20Instances%20,C5%20instances%20for%20a)), effectively meaning 15% more performance at the same cost).
- M6g at $0.154 is about 19.8% cheaper than M5/M6i. In addition, many workloads will run at least as fast on M6g as on M5 – in fact, AWS’s claim of 40% better price-performance suggests something like _20% lower cost + 20% higher performance_ in many cases ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=This%20big%20data%20heavy%20workload,benefits%20compared%20to%20M5%20instances)). Internal customer testing (Arm Treasure Data) found exactly that: 30% performance boost and 20% cost savings vs M5 ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=This%20big%20data%20heavy%20workload,benefits%20compared%20to%20M5%20instances)). So M6g is both cheaper and faster for lots of general-purpose use cases (web apps, microservices, etc.).
- M7g is a newer introduction (2023) and AWS priced it slightly higher than M6g but still well below x86. At $0.1632, it’s ~15% cheaper than M6i. Meanwhile, it delivers roughly 25% more compute performance than M6g ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=High%20performance%20for%20general%20purpose,workloads%20in%20Amazon%20EC2)). If we compare M7g to an M6i: performance-wise, Graviton3 (M7g) vs Intel (M6i) will vary by workload, but considering Graviton3 is ~25% over Graviton2, and Graviton2 was on par or better than M5, we can expect M7g to handily outperform M5 and likely outperform M6i in many cases (especially in workloads that benefit from Graviton3’s enhanced SIMD or crypto engines). At the very least, M7g’s 15% cost advantage means even at equal performance you save money, and if performance is better, that’s extra gain.

One way to think of it: If an application needs, say, 1000 units of work done per second:

- On M6i.xlarge, perhaps you need 4 instances, each costing $0.192, total $0.768/h.
- On M6g.xlarge, you might handle that with 3 instances (due to better efficiency) at $0.154 each, total $0.462/h – a **40%+ reduction in cost**.
- On M7g.xlarge, maybe 2-3 instances could do it (with Graviton3’s higher per-core performance) at $0.1632 each. Even if it’s 3 instances, that’s $0.4896/h, still far less than x86, and if 2 could handle it, that’s only $0.3264/h (a dramatic saving).

Of course, exact numbers depend on the workload, but these instances illustrate how moving to Graviton can reduce both the number of instances needed and the cost per instance.

**Reserved Instances/Savings Plans:** For general purpose, EC2 offers the same percentage discounts for RIs or Savings Plans regardless of CPU architecture. Typically, a 1-year commitment with partial upfront might cut ~30% off, and 3-year up to ~60% off the on-demand rate. These percentage cuts apply to both x86 and Graviton instances. Therefore, the **relative savings** of Graviton vs x86 remain roughly the same in percentage terms. For example, if M6i saves 0% (baseline) and M6g saves ~20% on-demand, under a savings plan M6i might be $0.134 and M6g $0.107 (just illustrative) – the ~20% difference persists. In fact, committing to Graviton can magnify _absolute_ savings over time: over 3 years, the dollar difference adds up more significantly. AWS encourages using Compute Savings Plans to lock in lower rates on Graviton, since you’re confident you will continue using them given the performance gains. Some customers combined Savings Plans with Graviton migration to great effect – for instance, FarEye saved $1 million annually by using Compute Savings Plans _and_ moving their workloads to Graviton and Spot ([FarEye saves $1 million annually with AWS Graviton - Amazon.com](https://aws.amazon.com/solutions/case-studies/fareye-case-study/#:~:text=FarEye%20saves%20%241%20million%20annually,Graviton%20Processors%20to%20support%20growth)).

**Equivalency Mapping:** For general purpose workloads, AWS’s recommended equivalence is **M5 -> M6g** (same vCPU/memory, better perf), and if you’re already on M6i, the step is **M6i -> M7g** for the next jump. Many AWS guides use M5 to M6g as a prime example because that’s where the largest jump occurs (older Intel to newer Graviton). Similarly, one could consider **M5 large -> M6g large** or **M5 2xlarge -> M6g 2xlarge**, etc., as drop-in replacements, expecting lower cost and equal or better performance.

### Compute Optimized: C5 / C6i vs C6g / C7g

Compute optimized instances have a higher CPU-to-memory ratio (2 GiB per vCPU) and are ideal for CPU-heavy tasks (batch processing, high-performance web servers, etc.). Let’s compare C5, C6i (Intel) with C6g (Graviton2) and C7g (Graviton3):

| Instance Type                   | vCPUs | Memory | On-Demand Cost (us-east-1)                                                                                                                                                                         | Notes                                                                                                                                                                                                                                                                                                                                                                                             |
| ------------------------------- | ----- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **c5.xlarge** (Intel, 5th Gen)  | 4     | 8 GiB  | $0.1700 per hour ([c5.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/c5.xlarge#:~:text=Comparison%20instances,17%20per%20hour))                   | Base x86 compute instance.                                                                                                                                                                                                                                                                                                                                                                        |
| **c6i.xlarge** (Intel, 6th Gen) | 4     | 8 GiB  | $0.1700 per hour ([c6i.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/c6i.xlarge#:~:text=Comparison%20instances,17%20per%20hour))                 | New gen x86, same price as C5. ~15% perf gain vs C5 ([Amazon EC2 C6i Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6i/#:~:text=Amazon%20EC2%20C6i%20Instances%20,C5%20instances%20for%20a)).                                                                                                                                                                        |
| **c6g.xlarge** (Graviton2)      | 4     | 8 GiB  | $0.1360 per hour ([c6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/c6g.xlarge#:~:text=c6g.xlarge%20pricing%20and%20specs%20,136%20per%20hour)) | ~20% lower cost than C5/C6i. Up to 40% better price-perf vs C5 ([Amazon EC2 C6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6g/#:~:text=Amazon%20EC2%20C6g%20Instances%20,price%20performance%20over%20C5%20instances)).                                                                                                                                          |
| **c7g.xlarge** (Graviton3)      | 4     | 8 GiB  | $0.1450 per hour ([c7g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/c7g.xlarge#:~:text=Comparison%20instances,145%20per%20hour))                | ~15% lower cost than C6i. ~25% better compute perf vs C6g ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=The%20latest%20generation%20compute%20optimized,inference%2C%20and%20ad%20serving)). Offers DDR5 and highest per-core performance. |

**Analysis:** The pattern is very similar to the M family:

- C5 and C6i are $0.17 for 4vCPU/8GiB. C6i brings improved performance at same cost (advertised 15% better price-perf ([Amazon EC2 C6i Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6i/#:~:text=Amazon%20EC2%20C6i%20Instances%20,C5%20instances%20for%20a))).
- C6g at $0.136 is exactly 20% cheaper than $0.17. AWS similarly claimed _“up to 40% better price-performance over C5”_ when C6g launched ([Amazon EC2 C6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/c6g/#:~:text=Amazon%20EC2%20C6g%20Instances%20,price%20performance%20over%20C5%20instances)). For pure compute tasks, Graviton2 has excelled – many CPU-intensive workloads (like compression, encoding, web serving) have shown 30-40% higher throughput on C6g vs C5, while paying 20% less per hour.
- C7g at $0.145 is a bit more than C6g, but still ~15% cheaper than x86. Graviton3 (C7g) also introduced features beneficial for compute tasks: notably, it’s the first EC2 instance to use DDR5 memory, giving 50% more memory bandwidth ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=performance%2C%20including%20support%20for%20bfloat16%2C,and%20secure%20cloud%20services%20with)). For compute-bound tasks that occasionally hit memory, this helps. Graviton3 also has more advanced SIMD (SVE) which can accelerate certain vectorizable workloads. So for HPC or scientific computing, C7g instances can significantly outperform C6g. (The AWS announcement noted _25% better performance on diverse workloads vs C6g_ ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=The%20latest%20generation%20compute%20optimized,inference%2C%20and%20ad%20serving)); and in specialized cases like cryptography or ML inference, even bigger gains up to 2-3× vs C6g ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=AWS%20Graviton3%20processors%20are%20the,less%20energy%20for%20the%20same)).)

**Customer Example:** Formula 1 (F1) ran computational fluid dynamics (CFD) simulations on C7g vs C6g and saw a 40% performance improvement ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=up%20to%2080,latency%20compared%20with%20C6g%20for)) – that implies a _huge_ advantage over older x86 (C5) at much lower cost. Also, an EDA company (Cadence) reported that even memory-heavy chip design jobs ran well on R6g and looked forward to larger Graviton instances (X2gd, Hpc7g) for more gains ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,intensive%20EDA%20workloads.%E2%80%9D)). These underscore that compute-optimized Graviton instances can tackle even the most demanding compute workloads.

**Equivalency:** **C5 -> C6g** is the main jump. If an application uses C5 (or older C4) today, moving to C6g is recommended for immediate cost and performance benefits. For those on C6i already, the next step is **C6i -> C7g**. Additionally, AWS introduced variants like C6gn (Graviton2 with enhanced 100 Gbps networking) that have no direct x86 equivalent – these are great for network-bound workloads. Generally, if you have a lot of C5.xlarge, expect that C6g.xlarge will give the same or better throughput per instance at lower cost, meaning you can save ~20-25% right away.

**Savings Plans impact:** Same story – both x86 and Arm prices go down with a plan, but Arm remains relatively cheaper. In compute optimized, where many are running large fleets, even a small per-instance difference multiplies. For example, a 1000-instance C6i.xlarge fleet costs $170/hour; the same fleet on C6g.xlarge costs $136/hour, saving $34/hour (~$250k per year on-demand). With a 1-year Savings Plan, you might reduce it to ~$119/hour vs $95/hour, still a ~$24/hour difference ( ~$175k/year). So committing doesn’t reduce the _advantage_ of Graviton; the cost gap persists.

### Memory Optimized: R5 / R6i vs R6g / R7g

Memory optimized instances have 8 GiB per vCPU and target databases, in-memory caches, etc. We compare R5, R6i (x86) to R6g (Graviton2) and R7g (Graviton3).

| Instance Type                   | vCPUs | Memory | On-Demand Cost (us-east-1)                                                                                                                                                                                      | Notes                                                                                                                                                                                                                                                                                       |
| ------------------------------- | ----- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **r5.xlarge** (Intel, 5th Gen)  | 4     | 32 GiB | ~$0.252 per hour ([r5.xlarge pricing: $183.96 monthly - AWS EC2 - Economize Cloud](https://www.economize.cloud/resources/aws/pricing/ec2/r5.xlarge/#:~:text=r5.xlarge%20pricing%3A%20%24183.96%20monthly%20,1)) | Baseline x86 memory optimized.                                                                                                                                                                                                                                                              |
| **r6i.xlarge** (Intel, 6th Gen) | 4     | 32 GiB | $0.252 per hour ([r6i.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/r6i.xlarge#:~:text=Comparison%20instances,252%20per%20hour))                              | Latest Intel; improved perf vs R5, same price.                                                                                                                                                                                                                                              |
| **r6g.xlarge** (Graviton2)      | 4     | 32 GiB | $0.2016 per hour ([r6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/r6g.xlarge#:~:text=Comparison%20instances,2016%20per%20hour))                            | ~20% lower cost than R5/R6i. _Up to 40% better price-perf_ vs R5 ([Amazon EC2 R6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/r6g/#:~:text=Amazon%20EC2%20R6g%20Instances%20,price%20performance%20over%20R5%20instances)).                                  |
| **r7g.xlarge** (Graviton3)      | 4     | 32 GiB | $0.2142 per hour ([r7g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/r7g.xlarge#:~:text=Comparison%20instances,2142%20per%20hour))                            | ~15% lower cost than R6i. ~25% better perf vs R6g (Graviton3 benefits) ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=AWS%20announces%20the%20general%20availability,the%20%2066%20AWS%20Nitro)). |

**Analysis:**

- R5 and R6i are around $0.25 hourly (exactly $0.252 according to sources). R6i again offered performance gains (Intel Ice Lake CPUs, plus perhaps higher memory bandwidth on that platform) but cost remained the same.
- R6g at $0.2016 is exactly 20% cheaper than $0.252. This aligns with AWS’s 40% price-performance claim (20% cost savings + performance gains) ([Amazon EC2 R6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/r6g/#:~:text=Amazon%20EC2%20R6g%20Instances%20,price%20performance%20over%20R5%20instances)). For memory-heavy workloads like databases, the performance gain might come from Graviton’s faster memory throughput on a per-socket basis and the fact that you can sometimes use a slightly smaller instance to achieve the same throughput if the bottleneck was CPU. Amazon Aurora, for instance, supports Graviton and many customers have switched to R6g/R7g for better throughput per dollar.
- R7g at $0.2142 is a bit higher than R6g but still clearly cheaper than x86. Graviton3’s advantages (we keep repeating: ~25% more compute, 2× crypto, 50% more memory bandwidth with DDR5) particularly help workloads like in-memory caching (Redis) or real-time analytics on big data that need both strong CPU and memory speed. AWS noted R7g instances deliver _25% better performance than R6g_ ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=AWS%20announces%20the%20general%20availability,the%20%2066%20AWS%20Nitro)); and an external benchmark indicated up to 20–30% better throughput for Redis on R7g vs R6g at slightly higher cost, netting about 15% better price-performance for that use case.

**Equivalency:** **R5 -> R6g** is the natural move (and R6g was positioned also against older R5d etc., providing same memory but at less cost). For those on the newer R6i or the AMD-based R6a, the upgrade would be **R6i/R6a -> R7g**. Memory optimized instances often run long-lived services (databases might run for years), so here especially, taking advantage of **Reserved Instances** or **Savings Plans** with Graviton yields big savings. For example, Instructure (an ed-tech company) migrated its high-throughput databases to Graviton-based R6g and observed up to **30% higher throughput and 20% cost savings** for their workload ([Scaling Up to 30% While Reducing Costs by 20% Using AWS ...](https://aws.amazon.com/solutions/case-studies/instructure-case-study/#:~:text=Scaling%20Up%20to%2030,AWS%20Graviton%E2%80%93based%20Amazon%20EC2%20instances)) – exactly what the pricing suggests. Paytm (a large financial services provider) similarly moved to Graviton for their databases and achieved **35% cost savings and 30% performance improvement** ([Paytm Realizes 35% Savings and Up to 30% Application ... - AWS](https://aws.amazon.com/solutions/case-studies/paytm-graviton-case-study/#:~:text=Paytm%20Realizes%2035,payment%20and%20financial%20services)).

Memory optimized instances also have some specialized Graviton variants like X2gd (which has extra-large memory per vCPU and uses Graviton2). These provide even more options to optimize cost for memory-bound workloads. AWS has stated that Graviton is their best price-performance offering for databases like Amazon RDS as well. In fact, AWS now defaults many Aurora and RDS instance classes to Graviton options for new deployments because of the clear cost/perf benefits (and they have a _Graviton Challenge_ for RDS encouraging customers to switch).

### Summary of Cost Comparison

Across all the above families:

- Graviton2-based instances (t4g, m6g, c6g, r6g, etc.) tend to be **~20% lower in price** than the previous-gen x86 instances (t3, m5, c5, r5) they replace. They also generally deliver at least equal, often better, performance. This yields around **30-40% better price-performance** in favor of Graviton ([It is out: The CloudPanel for AWS Graviton](https://www.cloudpanel.io/blog/cloudpanel-for-aws-graviton/#:~:text=AWS%20announced%20that%20its%20M6g,than%20its%20own%20M5%20instances)) ([Amazon EC2 R6g Instances - Amazon Web Services](https://aws.amazon.com/ec2/instance-types/r6g/#:~:text=Amazon%20EC2%20R6g%20Instances%20,price%20performance%20over%20R5%20instances)).
- Graviton3-based instances (m7g, c7g, r7g) are priced slightly higher than Graviton2 (by ~6–7% in our xlarge comparisons) but still about **15% cheaper than latest-gen x86**. Graviton3 provides additional performance (roughly +25%), so it continues the trend of improving price-performance. Essentially, M7g/C7g/R7g give another 10-15% price-performance improvement over M6g/C6g/R6g, and a much larger advantage (40-50% better price-perf) over older x86 like M5/C5/R5.
- If using **Reserved Instances or Savings Plans**, both x86 and Arm costs go down linearly. There is no special extra discount unique to Graviton (aside from the lower base price), but the **savings compound** over long durations. For example, over a 3-year period, the cost difference between running an x86 fleet and a Graviton fleet could mean **millions saved**, on top of any performance or capacity gains. Organizations often take those savings and invest elsewhere (as cited in case studies ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=seamlessly%20migrated%20most%20of%20our,%E2%80%9D))).

To put it bluntly: If your workload is compatible, running it on AWS Graviton is almost always the financially and technically prudent choice. You pay less per hour, and you often need fewer hours of compute for the same work due to performance boosts. Over a fleet of instances, this is a multiplicative effect. The transition effort (Phase 2) is usually a one-time cost, whereas the savings in Phase 3 accrue continuously.

### AWS Recommended Instance Mappings

As a quick reference, here are AWS’s typical recommended Graviton replacements for common x86 instances:

- **t3 → t4g** (burstable general purpose)
- **m5 or m5n → m6g** (general purpose; m5n with enhanced networking to m6g which already has high networking by default)
- **m6i or m6a → m7g** (general purpose latest gen)
- **c5 or c5n → c6g** (compute optimized)
- **c6i or c6a → c7g** (compute optimized latest gen)
- **r5 or r5n → r6g** (memory optimized)
- **r6i or r6a → r7g** (memory optimized latest gen)
- **X1/X1e (older high-memory) → X2gd** (Graviton2 high-memory variant) or consider **R6g/R7g** if the absolute memory needed fits.
- **High I/O or disk needs:** If using e.g. I3 (older HDD), consider **Im4gn/Is4gen** (Graviton SSD instances) or **I4g** (Graviton2 storage-optimized) where available; if using D3 (dense storage), consider **D3g**.
- **GPU instances:** AWS offers G5g (Graviton2 + NVIDIA T4 GPU) for certain workloads; though most GPU instances remain x86, for graphics or Android gaming workloads G5g can be 20% lower cost than G4dn ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=Image%3A%20Anbox%20Cloud)) while delivering similar performance for those use cases (with the GPU doing most heavy work).

It’s notable that AWS is rapidly expanding Graviton into almost every instance family (including HPC (Hpc6g, Hpc7g), memory-optimized with local NVMe (M7gd, C7gd, R7gd), etc.). This means that whatever x86 instance type you use, there is likely a Graviton-based counterpart either already available or coming soon. AWS’s strategy is clearly to make Graviton the default for cost-conscious and performance-conscious customers.

---

**Conclusion:** Migrating EC2 workloads from x86 to AWS Graviton is a proven path to achieve better price-performance. Phase 1 showed that AWS and its customers have measured substantial gains (30-40% better efficiency and even higher in some cases). Phase 2 outlined that with proper planning and modern software practices, the migration effort can be managed with minimal disruption – supported by a growing ecosystem of tools and partner software for Arm. Phase 3’s cost analysis quantifies the savings: roughly 20% lower cost per hour and up to 2× performance in certain scenarios, which together yield a transformative reduction in cost per operation.

By taking advantage of AWS’s Graviton-powered instances, organizations can **lower their EC2 costs, boost application performance, and reduce energy usage**, all without sacrificing functionality or support. These benefits, reinforced by real-world success stories, make a strong value proposition for making the switch to Arm-based computing in the cloud.

**Sources:**

- AWS Graviton2 and Graviton3 official announcements and instance product pages ([It is out: The CloudPanel for AWS Graviton](https://www.cloudpanel.io/blog/cloudpanel-for-aws-graviton/#:~:text=AWS%20announced%20that%20its%20M6g,than%20its%20own%20M5%20instances)) ([Announcing new Amazon EC2 C7g instances powered by AWS Graviton3 processors](https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/#:~:text=AWS%20Graviton3%20processors%20are%20the,less%20energy%20for%20the%20same)) ([Introducing Amazon EC2 M7g and R7g Instances](https://aws.amazon.com/about-aws/whats-new/2023/02/amazon-ec2-m7g-r7g-instances/#:~:text=AWS%20announces%20the%20general%20availability,the%20%2066%20AWS%20Nitro)) ([Amazon EC2 M7g instances – AWS](https://aws.amazon.com/ec2/instance-types/m7g/#:~:text=High%20performance%20for%20general%20purpose,workloads%20in%20Amazon%20EC2))
- AWS case studies and testimonials (Ascend Money, Ably, Aerospike, etc.) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,for%20the%20underprivileged%20segments%20of)) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D)) ([AWS Graviton Customer & Partners Testimonials - Amazon Web Services](https://aws.amazon.com/ec2/graviton/customers/#:~:text=,%E2%80%9D))
- AWS Getting Started and Technical Guides for Graviton ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,g)) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=,source%20code%20and%20library%20dependencies)) ([AWS EC2 Graviton Getting Started Step-by-Step Guide](https://aws.amazon.com/ec2/graviton/getting-started/#:~:text=One%20of%20the%20major%20differences,latencies%20or%20error%20rates%20occur))
- Pricing data from AWS (us-east-1) and analyses ([t4g.large instance pricing of AWS-EC2](https://www.instance-pricing.com/provider=aws-ec2/instance=t4g.large#:~:text=ap,Ohio%29)) ([m6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/m6g.xlarge#:~:text=The%20m6g,154%20per%20hour)) ([c6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/c6g.xlarge#:~:text=c6g.xlarge%20pricing%20and%20specs%20,136%20per%20hour)) ([r6g.xlarge pricing and specs - Amazon EC2 Instance Comparison](https://instances.vantage.sh/aws/ec2/r6g.xlarge#:~:text=Comparison%20instances,2016%20per%20hour)).
